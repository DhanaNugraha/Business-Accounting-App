---

# ðŸ“Œ Final Prompt (add Reporting Service + types + examples)

**Context:**
Build a desktop-first, offline accounting app using **Tauri + React + TypeScript + SQLite (Prisma or Drizzle)**. Use the schema, seed data, and report queries from the previous prompt. Add a **typed reporting service** that wraps SQL queries and exposes clean functions to the UI.

## Add: Types

Create a `src/types/accounting.ts`:

```ts
export type AccountType = 'Asset' | 'Liability' | 'Equity' | 'Income' | 'Expense';

export interface Account {
  id: number;
  name: string;
  type: AccountType;
  parent_id?: number | null;
}

export interface Transaction {
  id: number;
  date: string; // ISO yyyy-mm-dd
  amount: number;
  debit_account_id: number;
  credit_account_id: number;
  description?: string | null;
}

export interface TrialBalanceRow {
  accountId: number;
  accountName: string;
  accountType: AccountType;
  debit: number;   // period or to date
  credit: number;  // period or to date
}

export interface BalanceRow {
  accountId: number;
  accountName: string;
  balance: number; // sign already normalized for the section
}

export interface BalanceSheet {
  asOf: string;
  assets: BalanceRow[];
  liabilities: BalanceRow[];
  equity: BalanceRow[];
  totals: { assets: number; liabilities: number; equity: number };
}

export interface IncomeStatement {
  periodStart: string;
  periodEnd: string;
  income: BalanceRow[];
  expenses: BalanceRow[];
  totals: { income: number; expenses: number; netIncome: number };
}

export interface CashFlowLine {
  date: string;
  amount: number;
  counterparty: string; // source/destination account name
}

export interface CashFlowDirect {
  periodStart: string;
  periodEnd: string;
  inflows: CashFlowLine[];
  outflows: CashFlowLine[];
  totals: { inflows: number; outflows: number; netCash: number };
}
```

## Add: ReportService

Create `src/services/ReportService.ts`. It should:

* Use the existing SQLite client (Prisma/Drizzle) or a thin SQL wrapper.
* Accept date parameters.
* Normalize signs (Assets show positive if debits > credits; Liabilities/Equity show positive if credits > debits).
* Aggregate totals.

```ts
// src/services/ReportService.ts
import { BalanceSheet, IncomeStatement, CashFlowDirect, BalanceRow, AccountType } from '@/types/accounting';
import { db } from '@/db/db'; // your existing client
// If using Drizzle/Prisma, replace raw SQL with ORM builder where convenient.

const CASH_ACCOUNT_NAME = 'Cash'; // from seed (id=1). Prefer name lookup to avoid hard-coding ids.

export class ReportService {
  static async getBalanceSheet(asOf: string): Promise<BalanceSheet> {
    // Helper to fetch balances by type with proper sign
    const fetchByType = async (type: AccountType, sign: 'debit' | 'credit'): Promise<BalanceRow[]> => {
      const rows = await db.execute(/* sql */`
        SELECT a.id as accountId, a.name as accountName,
               SUM(CASE WHEN t.debit_account_id = a.id THEN t.amount ELSE 0 END) AS deb,
               SUM(CASE WHEN t.credit_account_id = a.id THEN t.amount ELSE 0 END) AS cred
        FROM accounts a
        LEFT JOIN transactions t ON a.id IN (t.debit_account_id, t.credit_account_id) AND t.date <= ?
        WHERE a.type = ?
        GROUP BY a.id, a.name
      `, [asOf, type]);

      return rows.map((r: any) => {
        const deb = Number(r.deb || 0);
        const cred = Number(r.cred || 0);
        const balance = sign === 'debit' ? (deb - cred) : (cred - deb);
        return { accountId: r.accountId, accountName: r.accountName, balance };
      }).filter((r: BalanceRow) => Math.abs(r.balance) > 0.000001);
    };

    const assets = await fetchByType('Asset', 'debit');
    const liabilities = await fetchByType('Liability', 'credit');
    const equity = await fetchByType('Equity', 'credit');

    const sum = (xs: BalanceRow[]) => xs.reduce((a, x) => a + x.balance, 0);
    return {
      asOf,
      assets,
      liabilities,
      equity,
      totals: {
        assets: sum(assets),
        liabilities: sum(liabilities),
        equity: sum(equity),
      },
    };
  }

  static async getIncomeStatement(start: string, end: string): Promise<IncomeStatement> {
    const fetchType = async (type: AccountType, positiveWhen: 'credit' | 'debit') => {
      const rows = await db.execute(/* sql */`
        SELECT a.id as accountId, a.name as accountName,
               SUM(CASE WHEN t.debit_account_id = a.id THEN t.amount ELSE 0 END) AS deb,
               SUM(CASE WHEN t.credit_account_id = a.id THEN t.amount ELSE 0 END) AS cred
        FROM accounts a
        LEFT JOIN transactions t ON a.id IN (t.debit_account_id, t.credit_account_id)
           AND t.date BETWEEN ? AND ?
        WHERE a.type = ?
        GROUP BY a.id, a.name
      `, [start, end, type]);

      return rows.map((r: any) => {
        const deb = Number(r.deb || 0), cred = Number(r.cred || 0);
        const balance = positiveWhen === 'credit' ? (cred - deb) : (deb - cred);
        return { accountId: r.accountId, accountName: r.accountName, balance };
      }).filter((r: BalanceRow) => Math.abs(r.balance) > 0.000001);
    };

    const income = await fetchType('Income', 'credit');
    const expenses = await fetchType('Expense', 'debit');

    const sum = (xs: BalanceRow[]) => xs.reduce((a, x) => a + x.balance, 0);
    const totalIncome = sum(income);
    const totalExpenses = sum(expenses);

    return {
      periodStart: start,
      periodEnd: end,
      income,
      expenses,
      totals: {
        income: totalIncome,
        expenses: totalExpenses,
        netIncome: totalIncome - totalExpenses,
      },
    };
  }

  static async getCashFlowDirect(start: string, end: string): Promise<CashFlowDirect> {
    // Look up Cash account id by name to avoid hardcoding
    const cash = await db.execute(`SELECT id FROM accounts WHERE name = ? LIMIT 1`, [CASH_ACCOUNT_NAME]);
    const cashId = cash?.[0]?.id;
    if (!cashId) throw new Error('Cash account not found');

    const inflows = await db.execute(/* sql */`
      SELECT t.date as date, t.amount as amount, ac.name as counterparty
      FROM transactions t
      JOIN accounts ad ON ad.id = t.debit_account_id
      JOIN accounts ac ON ac.id = t.credit_account_id
      WHERE t.debit_account_id = ?
        AND t.date BETWEEN ? AND ?
      ORDER BY t.date ASC
    `, [cashId, start, end]);

    const outflows = await db.execute(/* sql */`
      SELECT t.date as date, t.amount as amount, ad.name as counterparty
      FROM transactions t
      JOIN accounts ad ON ad.id = t.debit_account_id
      JOIN accounts ac ON ac.id = t.credit_account_id
      WHERE t.credit_account_id = ?
        AND t.date BETWEEN ? AND ?
      ORDER BY t.date ASC
    `, [cashId, start, end]);

    const sum = (xs: any[]) => xs.reduce((a, x) => a + Number(x.amount || 0), 0);
    return {
      periodStart: start,
      periodEnd: end,
      inflows,
      outflows,
      totals: {
        inflows: sum(inflows),
        outflows: sum(outflows),
        netCash: sum(inflows) - sum(outflows),
      },
    };
  }
}
```

## Add: Example usage in a React page

```tsx
// src/pages/Reports.tsx
import { useEffect, useState } from 'react';
import { ReportService } from '@/services/ReportService';

export default function ReportsPage() {
  const [asOf, setAsOf] = useState('2025-12-31');
  const [start, setStart] = useState('2025-01-01');
  const [end, setEnd] = useState('2025-12-31');

  const [bs, setBs] = useState<any>(null);
  const [isr, setIsr] = useState<any>(null);
  const [cf, setCf] = useState<any>(null);

  useEffect(() => {
    (async () => {
      setBs(await ReportService.getBalanceSheet(asOf));
      setIsr(await ReportService.getIncomeStatement(start, end));
      setCf(await ReportService.getCashFlowDirect(start, end));
    })();
  }, [asOf, start, end]);

  return (
    <div className="p-6 space-y-8">
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="card p-4 rounded-2xl shadow">
          <h2 className="text-xl font-semibold">Balance Sheet</h2>
          <div className="text-sm opacity-70">As of {asOf}</div>
          <pre className="mt-2 text-sm overflow-auto">{JSON.stringify(bs, null, 2)}</pre>
        </div>
        <div className="card p-4 rounded-2xl shadow">
          <h2 className="text-xl font-semibold">Income Statement</h2>
          <div className="text-sm opacity-70">{start} â†’ {end}</div>
          <pre className="mt-2 text-sm overflow-auto">{JSON.stringify(isr, null, 2)}</pre>
        </div>
        <div className="card p-4 rounded-2xl shadow">
          <h2 className="text-xl font-semibold">Cash Flow (Direct)</h2>
          <div className="text-sm opacity-70">{start} â†’ {end}</div>
          <pre className="mt-2 text-sm overflow-auto">{JSON.stringify(cf, null, 2)}</pre>
        </div>
      </div>
    </div>
  );
}
```

## Add: Minimal tests (optional but helpful)

Create `src/services/__tests__/ReportService.test.ts` (use Vitest/Jest; mock `db.execute`):

```ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { ReportService } from '../ReportService';

vi.mock('@/db/db', () => ({
  db: { execute: vi.fn() }
}));
import { db } from '@/db/db';

describe('ReportService', () => {
  beforeEach(() => vi.clearAllMocks());

  it('computes Balance Sheet totals', async () => {
    // mock assets/liabilities/equity queries returning simple rows
    (db.execute as any).mockImplementation((sql: string) => {
      if (sql.includes('WHERE a.type = \'Asset\'')) return Promise.resolve([{ accountId: 1, accountName: 'Cash', deb: 1000, cred: 200 }]);
      if (sql.includes('WHERE a.type = \'Liability\'')) return Promise.resolve([{ accountId: 6, accountName: 'AP', deb: 0, cred: 300 }]);
      if (sql.includes('WHERE a.type = \'Equity\'')) return Promise.resolve([{ accountId: 9, accountName: 'Capital', deb: 0, cred: 500 }]);
      return Promise.resolve([]);
    });
    const bs = await ReportService.getBalanceSheet('2025-12-31');
    expect(bs.totals.assets).toBe(800);     // 1000-200
    expect(bs.totals.liabilities).toBe(300);
    expect(bs.totals.equity).toBe(500);
  });
});
```

## Small DB enhancements (ask the AI to include)

* Add indexes:

```sql
CREATE INDEX IF NOT EXISTS idx_transactions_date ON transactions(date);
CREATE INDEX IF NOT EXISTS idx_transactions_debit ON transactions(debit_account_id);
CREATE INDEX IF NOT EXISTS idx_transactions_credit ON transactions(credit_account_id);
CREATE UNIQUE INDEX IF NOT EXISTS idx_accounts_name ON accounts(name);
```

* Add simple CHECK to prevent same debit/credit account:

```sql
ALTER TABLE transactions ADD COLUMN _guard INTEGER GENERATED ALWAYS AS (CASE WHEN debit_account_id = credit_account_id THEN 1 ELSE 0 END) VIRTUAL;
-- Or enforce in application layer if SQLite build doesnâ€™t support VIRTUAL/GAS columns reliably.
```

---

**Deliverables:**

1. `ReportService.ts` as above.
2. Types file.
3. React Reports page example.
4. Indices for performance.
5. Keep all previous schema, seed accounts, sample transactions, and report SQL logic.

---
